<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jeu vocal — Balle chantée</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: sans-serif;
      background: linear-gradient(135deg, #ffeb3b, #ff9800, #000);
      overflow: hidden;
    }
    #backgroundSymbols {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    #menu {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.75);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 2;
      color: white;
      width: 90%;
      max-width: 360px;
    }
    button {
      display: block;
      width: 100%;
      padding: 12px;
      margin: 10px auto;
      font-size: 1.1em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    button:disabled {
      background: #888;
      color: #333;
      cursor: not-allowed;
    }
    .note-btn { background: #e91e63; color: white; }
    .note-btn.listening { background: #4caf50; }
    .note-display { margin: 8px 0; font-size: 1.3em; min-height: 1.4em; }
    .freq-display { font-size: 1em; color: #ffc; }
    #startGameBtn { background: #ff9800; color: black; }

    #gameCanvas {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: transparent;
      border: 3px solid #ff9800;
      border-radius: 15px;
      z-index: 1;
      display: none;
    }
    #scoreDisplay {
      position: fixed;
      top: 20px; right: 20px;
      font-size: 24px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 1px 1px 3px #000;
      z-index: 2;
    }
    #replayBtn {
      position: fixed;
      bottom: 20px; right: 20px;
      padding: 12px 20px;
      background: #ff9800;
      color: black;
      border: none;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      display: none;
      z-index: 2;
    }
  </style>
</head>
<body>

<canvas id="backgroundSymbols"></canvas>

<div id="menu">
  <h1>Choisis ta tessiture</h1>
  <button id="listenLowBtn" class="note-btn">🎤 Écouter note basse</button>
  <div class="note-display" id="lowNoteDisplay">–</div>
  <div class="freq-display" id="lowFreqDisplay"></div>

  <button id="listenHighBtn" class="note-btn">🎤 Écouter note haute</button>
  <div class="note-display" id="highNoteDisplay">–</div>
  <div class="freq-display" id="highFreqDisplay"></div>

  <button id="startGameBtn" disabled>Démarrer le jeu</button>
</div>

<canvas id="gameCanvas" width="480" height="640"></canvas>
<div id="scoreDisplay"></div>
<button id="replayBtn">Rejouer</button>

<!-- Librairie Pitchfinder UMD -->
<script src="https://unpkg.com/pitchfinder/dist/pitchfinder.umd.js"></script>

<script>
  if (!window.Pitchfinder) {
    alert("Pitchfinder non chargé ! Assure-toi d’ouvrir ce fichier via un serveur local (ex: Python http.server ou Live Server).");
  }

  const detectPitch = Pitchfinder.YIN();

  // === Fond animé ===
  const bg = document.getElementById('backgroundSymbols');
  const bgCtx = bg.getContext('2d');
  const syms = ['♩','♪','♫','♬','♭','♯'];
  let objs = [];

  function resizeBg() {
    bg.width = window.innerWidth;
    bg.height = window.innerHeight;
    objs = Array.from({length: 80}, () => ({
      x: Math.random()*bg.width,
      y: Math.random()*bg.height,
      size: 12 + Math.random()*30,
      angle: (Math.random()-0.5)*1,
      sym: syms[Math.floor(Math.random()*syms.length)],
      alpha: 0.02 + Math.random()*0.06
    }));
  }

  function animateBg() {
    bgCtx.clearRect(0, 0, bg.width, bg.height);
    objs.forEach(o => {
      bgCtx.save();
      bgCtx.translate(o.x, o.y);
      bgCtx.rotate(o.angle);
      bgCtx.globalAlpha = o.alpha;
      bgCtx.fillStyle = "#fff";
      bgCtx.font = `${o.size}px serif`;
      bgCtx.fillText(o.sym, 0, 0);
      bgCtx.restore();
    });
    requestAnimationFrame(animateBg);
  }

  window.addEventListener('resize', resizeBg);
  resizeBg();
  animateBg();

  // === Détection micro et tessiture ===
  let audioCtx, analyser, buf, stream, listeningFor = null;
  let lowFreq = null, highFreq = null;

  const lowNote = document.getElementById("lowNoteDisplay");
  const highNote = document.getElementById("highNoteDisplay");
  const lowFreqDisplay = document.getElementById("lowFreqDisplay");
  const highFreqDisplay = document.getElementById("highFreqDisplay");

  const listenLowBtn = document.getElementById("listenLowBtn");
  const listenHighBtn = document.getElementById("listenHighBtn");
  const startGameBtn = document.getElementById("startGameBtn");

  listenLowBtn.onclick = () => listeningFor==='low' ? stopListen() : startListen('low');
  listenHighBtn.onclick = () => listeningFor==='high' ? stopListen() : startListen('high');

  async function safeCloseAudioContext() {
    if (!audioCtx) return;
    try { if(audioCtx.state!=='closed') await audioCtx.close(); } catch(e){console.warn(e);}
    audioCtx = null;
  }

  async function stopListen() {
    if (stream) { stream.getTracks().forEach(t=>t.stop()); stream=null; }
    await safeCloseAudioContext();
    listeningFor=null;
    [listenLowBtn,listenHighBtn].forEach(b=>b.classList.remove('listening'));
    listenLowBtn.textContent="🎤 Écouter note basse";
    listenHighBtn.textContent="🎤 Écouter note haute";
    lowNote.textContent=highNote.textContent="–";
    lowFreqDisplay.textContent=highFreqDisplay.textContent="";
    lowFreq=highFreq=null;
    startGameBtn.disabled=true;
  }

  async function startListen(type) {
    await stopListen();
    listeningFor=type;
    const btn = type==='low'?listenLowBtn:listenHighBtn;
    btn.classList.add('listening');
    btn.textContent=type==='low'?"⏸ Arrêter écoute basse":"⏸ Arrêter écoute haute";
    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize=2048;
      buf = new Float32Array(analyser.fftSize);
      src.connect(analyser);
      detectPitchLoop();
    } catch(e) {
      alert("Micro inaccessible.");
      listeningFor=null;
      btn.classList.remove('listening');
      btn.textContent=type==='low'?"🎤 Écouter note basse":"🎤 Écouter note haute";
    }
  }

  function freqToNoteLabel(freq){
    const noteNames=["Do","Do♯","Ré","Ré♯","Mi","Fa","Fa♯","Sol","Sol♯","La","La♯","Si"];
    const flatEquivs={"Do♯":"Ré♭","Ré♯":"Mi♭","Fa♯":"Sol♭","Sol♯":"La♭","La♯":"Si♭"};
    const noteNumber=12*(Math.log2(freq/440))+69;
    const rounded=Math.round(noteNumber);
    let name=noteNames[(rounded+1200)%12];
    if(flatEquivs[name]) name=flatEquivs[name];
    const octave=Math.floor(rounded/12)-1;
    return name+octave;
  }

  function detectPitchLoop(){
    if(!listeningFor||!audioCtx||!analyser) return;
    analyser.getFloatTimeDomainData(buf);
    const freq = detectPitch(buf);
    if(freq && isFinite(freq)){
      const noteLabel=freqToNoteLabel(freq);
      const freqLabel=freq.toFixed(1)+" Hz";
      if(listeningFor==='low'){ lowNote.textContent=noteLabel; lowFreqDisplay.textContent=freqLabel; lowFreq=freq; }
      else { highNote.textContent=noteLabel; highFreqDisplay.textContent=freqLabel; highFreq=freq; }
      if(lowFreq && highFreq && highFreq>lowFreq+10) startGameBtn.disabled=false;
    } else {
      if(listeningFor==='low'){ lowNote.textContent="–"; lowFreqDisplay.textContent=""; lowFreq=null; }
      else { highNote.textContent="–"; highFreqDisplay.textContent=""; highFreq=null; }
      startGameBtn.disabled=true;
    }
    requestAnimationFrame(detectPitchLoop);
  }

  // === Jeu ===
  const canvas=document.getElementById('gameCanvas');
  const ctx=canvas.getContext('2d');
  const scoreDisplay=document.getElementById('scoreDisplay');
  const replayBtn=document.getElementById('replayBtn');
  const menuDiv=document.getElementById('menu');

  let gameRunning=false, obstacles=[], ball={x:50,y:0,radius:15,vy:0}, gravity=0.6, frameCount=0, score=0;
  const gameHeight=canvas.height, gameWidth=canvas.width;

  function freqToY(freq){
    if(!lowFreq||!highFreq) return gameHeight/2;
    const ratio=(Math.min(Math.max(freq,lowFreq),highFreq)-lowFreq)/(highFreq-lowFreq);
    return gameHeight-ratio*gameHeight;
  }

  function createObstacle(){
    const holeHeight=120,holeY=Math.random()*(gameHeight-holeHeight);
    return {x:gameWidth+20,width:50,holeY,holeHeight,passed:false};
  }

  function resetGame(){ obstacles=[]; ball.x=50; ball.y=gameHeight/2; ball.vy=0; frameCount=0; score=0; scoreDisplay.textContent="Score: 0"; replayBtn.style.display='none'; }

  function gameOver(){ gameRunning=false; replayBtn.style.display='block'; }

  function drawObstacle(obs){ ctx.fillStyle='#ff9800'; ctx.fillRect(obs.x,0,obs.width,obs.holeY); ctx.fillRect(obs.x,obs.holeY+obs.holeHeight,obs.width,gameHeight-(obs.holeY+obs.holeHeight)); }

  function drawBall(){ ctx.beginPath(); ctx.fillStyle='#e91e63'; ctx.shadowColor='rgba(255,20,147,0.7)'; ctx.shadowBlur=12; ctx.arc(ball.x,ball.y,ball.radius,0,2*Math.PI); ctx.fill(); ctx.shadowBlur=0; }

  function drawBackgroundSymbolsInGame(){
    const symbols=['♩','♪','♫','♬','♭','♯'];
    ctx.fillStyle='rgba(255,235,59,0.1)'; ctx.font='30px serif';
    for(let i=0;i<15;i++){
      const x=(i*60+frameCount*2)%canvas.width, y=(i*40+frameCount)%canvas.height;
      ctx.fillText(symbols[i%symbols.length],x,y);
    }
  }

  function update(){
    if(!gameRunning) return;
    frameCount++;
    if(frameCount%120===0) obstacles.push(createObstacle());
    obstacles.forEach(obs=>obs.x-=3);
    obstacles=obstacles.filter(obs=>obs.x+obs.width>0);

    let freq=-1;
    if(audioCtx&&analyser&&buf){ analyser.getFloatTimeDomainData(buf); freq=detectPitch(buf); }
    if(freq>0) ball.y=freqToY(freq);

    for(const obs of obstacles){
      if(ball.x+ball.radius>obs.x && ball.x-ball.radius<obs.x+obs.width){
        if(ball.y-ball.radius<obs.holeY || ball.y+ball.radius>obs.holeY+obs.holeHeight) gameOver();
      }
      if(!obs.passed && obs.x+obs.width<ball.x){ obs.passed=true; score++; scoreDisplay.textContent="Score: "+score; }
    }

    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackgroundSymbolsInGame();
    obstacles.forEach(drawObstacle);
    drawBall();

    requestAnimationFrame(update);
  }

  startGameBtn.onclick=()=>{
    if(!lowFreq || !highFreq || highFreq<=lowFreq+10){ alert("Veuillez définir correctement la tessiture."); return; }
    menuDiv.style.display='none'; canvas.style.display='block'; scoreDisplay.style.display='block'; replayBtn.style.display='none';
    gameRunning=true; resetGame();
    startGameMic();
    update();
  }

  replayBtn.onclick=()=>{ replayBtn.style.display='none'; resetGame(); gameRunning=true; update(); }

  function startGameMic(){
    if(stream) stream.getTracks().forEach(t=>t.stop());
    if(audioCtx) audioCtx.close();
    navigator.mediaDevices.getUserMedia({ audio:true })
      .then(s=>{ stream=s; audioCtx=new AudioContext(); const src=audioCtx.createMediaStreamSource(stream); analyser=audioCtx.createAnalyser(); analyser.fftSize=2048; buf=new Float32Array(analyser.fftSize); src.connect(analyser); })
      .catch(()=>alert("Microphone non accessible, jeu indisponible."));
  }
</script>
</body>
</html>
