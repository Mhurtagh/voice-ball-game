<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jeu de la Balle Chant√©e</title>
<style>
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #ffeb3b, #ff9800, #000);
    overflow: hidden;
    position: relative;
    color: white;
  }
  /* Canvas de fond plein √©cran pour symboles musicaux */
  #backgroundSymbols {
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
    z-index: 0;
    user-select: none;
  }

  #menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    z-index: 10;
    max-width: 320px;
    width: 90vw;
  }
  #menu h1 {
    margin-bottom: 20px;
    font-size: 1.8em;
    letter-spacing: 1.5px;
  }
  button, select {
    background: #ff9800;
    border: none;
    padding: 12px 20px;
    margin: 10px 0;
    border-radius: 10px;
    font-size: 1em;
    color: #000;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s;
    width: 100%;
    max-width: 280px;
  }
  button:hover, select:hover {
    background: #ffc107;
  }
  button:disabled {
    background: #aaa;
    cursor: not-allowed;
    color: #444;
  }
  #listenLowBtn, #listenHighBtn {
    background: #e91e63;
    color: white;
  }
  #listenLowBtn.listening, #listenHighBtn.listening {
    background: #4caf50;
  }
  .note-display {
    margin: 8px 0;
    font-size: 1.2em;
    font-weight: 600;
    min-height: 1.5em;
  }
  label {
    display: block;
    margin-top: 15px;
    font-weight: 600;
    font-size: 1.1em;
    text-align: left;
  }

  #gameCanvas {
    display: none;
    background: transparent; /* on veut voir le fond musical */
    margin: 0 auto;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 3px solid #ff9800;
    border-radius: 15px;
    z-index: 5;
    user-select: none;
  }

  #scoreDisplay {
    position: fixed;
    top: 20px;
    right: 20px;
    font-size: 24px;
    font-weight: bold;
    color: #ffeb3b;
    text-shadow: 1px 1px 3px #000;
    z-index: 10;
    user-select: none;
  }

  #replayBtn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #ff9800;
    color: black;
    border: none;
    padding: 12px 20px;
    border-radius: 12px;
    font-weight: bold;
    font-size: 1.2em;
    cursor: pointer;
    display: none;
    z-index: 10;
    user-select: none;
  }
  #replayBtn:hover {
    background: #ffc107;
  }
</style>
</head>
<body>

<canvas id="backgroundSymbols"></canvas>

<div id="menu">
  <h1>Jeu de la Balle Chant√©e</h1>
  <label>Choisissez votre tessiture vocale :</label>
  <button id="listenLowBtn">üé§ D√©marrer √©coute note basse</button>
  <div class="note-display" id="lowNoteDisplay">Aucune note d√©tect√©e</div>
  <button id="listenHighBtn">üé§ D√©marrer √©coute note haute</button>
  <div class="note-display" id="highNoteDisplay">Aucune note d√©tect√©e</div>

  <button id="startGameBtn" disabled>D√©marrer le jeu</button>
</div>

<canvas id="gameCanvas" width="480" height="640"></canvas>
<div id="scoreDisplay"></div>
<button id="replayBtn">Rejouer</button>

<script>
/** FOND SYMBOLS MUSICAUX **/

const bgCanvas = document.getElementById('backgroundSymbols');
const bgCtx = bgCanvas.getContext('2d');

function resizeBgCanvas() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}
resizeBgCanvas();
window.addEventListener('resize', resizeBgCanvas);

const symbols = ['‚ô©', '‚ô™', '‚ô´', '‚ô¨', '‚ô≠', '‚ôØ'];
const symbolObjs = [];
const symbolCount = 70;
for(let i = 0; i < symbolCount; i++) {
  symbolObjs.push({
    x: Math.random() * bgCanvas.width,
    y: Math.random() * bgCanvas.height,
    size: 14 + Math.random() * 28,
    angle: (Math.random() - 0.5) * 0.8,
    symbol: symbols[Math.floor(Math.random() * symbols.length)],
    opacity: 0.03 + Math.random() * 0.07
  });
}

function drawBackgroundSymbols() {
  bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
  symbolObjs.forEach(obj => {
    bgCtx.save();
    bgCtx.translate(obj.x, obj.y);
    bgCtx.rotate(obj.angle);
    bgCtx.globalAlpha = obj.opacity;
    bgCtx.fillStyle = '#fff';
    bgCtx.font = `${obj.size}px serif`;
    bgCtx.fillText(obj.symbol, 0, 0);
    bgCtx.restore();
  });
}

function animateBackground() {
  drawBackgroundSymbols();
  requestAnimationFrame(animateBackground);
}
animateBackground();

/** MENU + LOGIQUE D'ECOUTE **/

// Notes en notation fran√ßaise avec b√©mols (# => di√®se, b => b√©mol)
const NOTES_FR = ['do', 'do#', 'r√©', 'r√©#', 'mi', 'fa', 'fa#', 'sol', 'sol#', 'la', 'la#', 'si'];
const NOTES_BEMOL = {
  'do#': 'r√©b',
  'r√©#': 'mib',
  'fa#': 'solb',
  'sol#': 'lab',
  'la#': 'sib',
};
// Fonction pour convertir note anglaise en notation fran√ßaise avec b√©mols
function toFrenchNote(noteName) {
  // noteName ex : 'A4' -> on prend la note sans octave
  // Ici on mappe note anglaise vers fran√ßaise, en di√®se ou b√©mol selon config
  const mapping = {
    'C': 'do', 'C#': 'do#', 'Db': 'r√©b',
    'D': 'r√©', 'D#': 'r√©#', 'Eb': 'mib',
    'E': 'mi',
    'F': 'fa', 'F#': 'fa#', 'Gb': 'solb',
    'G': 'sol', 'G#': 'sol#', 'Ab': 'lab',
    'A': 'la', 'A#': 'la#', 'Bb': 'sib',
    'B': 'si'
  };
  // On s√©pare lettre + di√®se/b√©mol + octave
  let baseNote = noteName.slice(0, -1);
  let octave = noteName.slice(-1);
  if(mapping[baseNote]) {
    let french = mapping[baseNote];
    // si c'est un di√®se, on propose aussi le b√©mol √©quivalent
    if(NOTES_BEMOL[french]) return french + octave + " / " + NOTES_BEMOL[french] + octave;
    return french + octave;
  }
  return noteName; // fallback
}

// Reconnaissance audio basique avec pitch detection (Pitch.js ou autre)
// Ici on utilise une impl√©mentation simple via Web Audio API et autocorrelation

// Source pitch detection (simplifi√©e)
async function getUserMediaStream() {
  try {
    return await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    alert("Erreur : acc√®s au micro refus√© ou non disponible.");
    throw err;
  }
}

// Pitch detection par autocorr√©lation
function autoCorrelate(buffer, sampleRate) {
  // Algorithm adapted from https://github.com/cwilso/PitchDetect
  let SIZE = buffer.length;
  let MAX_SAMPLES = Math.floor(SIZE / 2);
  let bestOffset = -1;
  let bestCorrelation = 0;
  let rms = 0;
  for(let i = 0; i < SIZE; i++) {
    let val = buffer[i];
    rms += val*val;
  }
  rms = Math.sqrt(rms / SIZE);
  if(rms < 0.01) return -1; // bruit trop faible

  let correlations = new Array(MAX_SAMPLES);
  for(let offset = 0; offset < MAX_SAMPLES; offset++) {
    let correlation = 0;
    for(let i = 0; i < MAX_SAMPLES; i++) {
      correlation += Math.abs(buffer[i] - buffer[i + offset]);
    }
    correlation = 1 - (correlation / MAX_SAMPLES);
    correlations[offset] = correlation;
    if(correlation > bestCorrelation) {
      bestCorrelation = correlation;
      bestOffset = offset;
    }
  }
  if(bestCorrelation > 0.9) {
    return sampleRate / bestOffset;
  }
  return -1;
}

// Convert frequency (Hz) to note name (ex: 'A4')
function freqToNote(freq) {
  if(freq <= 0) return null;
  const A4 = 440;
  const SEMITONE = 69;
  const noteNum = Math.round(12 * Math.log2(freq / A4) + SEMITONE);
  const octave = Math.floor(noteNum / 12) - 1;
  const noteIndex = (noteNum % 12 + 12) % 12;
  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  return noteNames[noteIndex] + octave;
}

/** Gestion √©coute micro pour basse et haute tessiture **/

let audioContext, analyser, processor, source;
let listeningFor = null; // 'low' or 'high'
let stream;

const listenLowBtn = document.getElementById('listenLowBtn');
const listenHighBtn = document.getElementById('listenHighBtn');
const lowNoteDisplay = document.getElementById('lowNoteDisplay');
const highNoteDisplay = document.getElementById('highNoteDisplay');
const startGameBtn = document.getElementById('startGameBtn');

let detectedLowFreq = null;
let detectedHighFreq = null;

function stopListening() {
  if (processor) {
    processor.disconnect();
    processor.onaudioprocess = null;
    processor = null;
  }
  if (analyser) {
    analyser.disconnect();
    analyser = null;
  }
  if (source) {
    source.disconnect();
    source = null;
  }
  if (audioContext) {
    audioContext.close();
    audioContext = null;
  }
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
    stream = null;
  }
  listeningFor = null;
  listenLowBtn.classList.remove('listening');
  listenHighBtn.classList.remove('listening');
}

async function startListening(type) {
  if (listeningFor) stopListening();
  listeningFor = type;
  if (type === 'low') {
    listenLowBtn.textContent = '‚è∏Ô∏è Arr√™ter √©coute note basse';
    listenLowBtn.classList.add('listening');
  } else {
    listenHighBtn.textContent = '‚è∏Ô∏è Arr√™ter √©coute note haute';
    listenHighBtn.classList.add('listening');
  }
  try {
    stream = await getUserMediaStream();
  } catch(e) {
    listeningFor = null;
    if(type === 'low') {
      listenLowBtn.textContent = 'üé§ D√©marrer √©coute note basse';
      listenLowBtn.classList.remove('listening');
    } else {
      listenHighBtn.textContent = 'üé§ D√©marrer √©coute note haute';
      listenHighBtn.classList.remove('listening');
    }
    return;
  }

  audioContext = new AudioContext();
  source = audioContext.createMediaStreamSource(stream);
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 2048;
  source.connect(analyser);

  const buffer = new Float32Array(analyser.fftSize);

  function analysePitch() {
    analyser.getFloatTimeDomainData(buffer);
    const pitch = autoCorrelate(buffer, audioContext.sampleRate);
    if (pitch !== -1) {
      // On limite pitch dans gamme raisonnable (50 Hz - 1500 Hz)
      if(pitch >= 50 && pitch <= 1500) {
        const noteName = freqToNote(pitch);
        const frenchNote = toFrenchNote(noteName);
        if(type === 'low') {
          detectedLowFreq = pitch;
          lowNoteDisplay.textContent = frenchNote;
        } else {
          detectedHighFreq = pitch;
          highNoteDisplay.textContent = frenchNote;
        }
        checkStartButton();
      }
    }
    if(listeningFor === type) {
      requestAnimationFrame(analysePitch);
    }
  }
  analysePitch();
}

function checkStartButton() {
  if(detectedLowFreq && detectedHighFreq && detectedLowFreq < detectedHighFreq) {
    startGameBtn.disabled = false;
  } else {
    startGameBtn.disabled = true;
  }
}

listenLowBtn.addEventListener('click', () => {
  if(listeningFor === 'low') stopListening();
  else startListening('low');
});
listenHighBtn.addEventListener('click', () => {
  if(listeningFor === 'high') stopListening();
  else startListening('high');
});

/** JEU DE LA BALLE **/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const replayBtn = document.getElementById('replayBtn');
const menuDiv = document.getElementById('menu');

const CANVAS_WIDTH = canvas.width;
const CANVAS_HEIGHT = canvas.height;

let animationId;

let lowFreq, highFreq; // tessiture utilisateur

// Ball properties
const ballRadius = 15;
let ballX = CANVAS_WIDTH / 4;
let ballY = CANVAS_HEIGHT / 2;
let ballSpeedX = 3;
let ballSpeedY = 0;
let gravity = 0.15;

// Obstacles
const obstacleWidth = 60;
const gapMinHeight = 90;
const gapMaxHeight = 150;
const obstacleSpeed = 3;

let obstacles = [];
let frameCount = 0;
let score = 0;
let gameOver = false;

// Note cible affich√©e (doit passer dans le trou)
let targetNote = null;
let targetNoteFreq = null;

// Helper: fr√©quence en note fran√ßaise (b√©mol inclus) pour affichage
function freqToFrenchNoteClosest(freq) {
  if (!freq) return "";
  // Note la plus proche
  const noteName = freqToNote(freq);
  return toFrenchNote(noteName);
}

// Cr√©ation obstacles avec trous al√©atoires dans tessiture
function createObstacle() {
  // La position Y du trou sera entre lowFreq et highFreq, en hauteur pixel on calcule
  // On mappe la fr√©quence en position Y entre 50 px (haut) et CANVAS_HEIGHT - 50 px (bas)
  // plus haute freq = trou bas (car la balle monte avec freq)
  // pour la facilit√© on inverse la map (plus freq haute = trou plus bas)
  function freqToY(freq) {
    const minF = lowFreq;
    const maxF = highFreq;
    // clamp
    if(freq < minF) freq = minF;
    if(freq > maxF) freq = maxF;
    // map freq -> y (haut=50, bas=CANVAS_HEIGHT-50)
    const ratio = (freq - minF) / (maxF - minF);
    return CANVAS_HEIGHT - 50 - ratio * (CANVAS_HEIGHT - 100);
  }

  // Le trou est une plage verticale dans l'obstacle
  // On choisit al√©atoirement la note cible dans la tessiture
  const freqRange = highFreq - lowFreq;
  const randomFreq = lowFreq + Math.random() * freqRange;
  const holeCenterY = freqToY(randomFreq);
  const holeHeight = gapMinHeight + Math.random() * (gapMaxHeight-gapMinHeight);

  const obstacle = {
    x: CANVAS_WIDTH,
    holeY: holeCenterY,
    holeHeight,
    targetFreq: randomFreq,
  };
  obstacles.push(obstacle);
  targetNote = toFrenchNote(freqToNote(randomFreq));
  targetNoteFreq = randomFreq;
}

// Dessin du fond musical aussi dans le canvas de jeu (optionnel)
// Ici on peut dessiner quelques symboles al√©atoires discrets
function drawGameBackground() {
  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
  const bgSymbolsCount = 25;
  ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
  ctx.font = '28px serif';
  for(let i = 0; i < bgSymbolsCount; i++) {
    let x = (i * 70 + frameCount * 1.2) % CANVAS_WIDTH;
    let y = (i * 50 + frameCount * 0.8) % CANVAS_HEIGHT;
    const sym = symbols[i % symbols.length];
    ctx.fillText(sym, x, y);
  }
}

// Dessin obstacles et trou
function drawObstacles() {
  ctx.fillStyle = '#ff9800';
  obstacles.forEach(obs => {
    // partie haute
    ctx.fillRect(obs.x, 0, obstacleWidth, obs.holeY - obs.holeHeight/2);
    // partie basse
    ctx.fillRect(obs.x, obs.holeY + obs.holeHeight/2, obstacleWidth, CANVAS_HEIGHT - (obs.holeY + obs.holeHeight/2));
    // contour du trou (ligne horizontale)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(obs.x, obs.holeY - obs.holeHeight/2);
    ctx.lineTo(obs.x + obstacleWidth, obs.holeY - obs.holeHeight/2);
    ctx.moveTo(obs.x, obs.holeY + obs.holeHeight/2);
    ctx.lineTo(obs.x + obstacleWidth, obs.holeY + obs.holeHeight/2);
    ctx.stroke();

    // afficher la note cible au-dessus du trou
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(toFrenchNote(freqToNote(obs.targetFreq)), obs.x + obstacleWidth/2, obs.holeY - obs.holeHeight/2 - 15);
  });
}

// Dessin balle
function drawBall() {
  ctx.beginPath();
  ctx.fillStyle = '#e91e63';
  ctx.shadowColor = '#ff4081';
  ctx.shadowBlur = 12;
  ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.closePath();
}

// Met √† jour position balle selon note chant√©e
function updateBallPosition(currentFreq) {
  if (!currentFreq) {
    // chute naturelle si pas de voix
    ballSpeedY += gravity;
    ballY += ballSpeedY;
    // limite au sol
    if(ballY > CANVAS_HEIGHT - ballRadius) {
      ballY = CANVAS_HEIGHT - ballRadius;
      ballSpeedY = 0;
    }
    return;
  }
  // On calcule la hauteur cible en pixel selon fr√©quence
  // on mappe lowFreq => bas canvas et highFreq => haut canvas (invers√©)
  function freqToY(freq) {
    const minF = lowFreq;
    const maxF = highFreq;
    // clamp
    if(freq < minF) freq = minF;
    if(freq > maxF) freq = maxF;
    // map freq -> y (haut=50, bas=CANVAS_HEIGHT-50)
    const ratio = (freq - minF) / (maxF - minF);
    return CANVAS_HEIGHT - 50 - ratio * (CANVAS_HEIGHT - 100);
  }
  const targetY = freqToY(currentFreq);
  // on approche doucement la balle vers la cible
  const diff = targetY - ballY;
  ballSpeedY = diff * 0.15;
  ballY += ballSpeedY;

  // d√©calage horizontal
  ballX += ballSpeedX;
}

// V√©rifie collisions balle/obstacles
function checkCollision() {
  for(let i=0; i < obstacles.length; i++) {
    const obs = obstacles[i];
    // obstacle proche balle (sur x)
    if(ballX + ballRadius > obs.x && ballX - ballRadius < obs.x + obstacleWidth) {
      // V√©rif si balle est dans le trou vertical
      if(ballY - ballRadius > obs.holeY - obs.holeHeight/2 &&
         ballY + ballRadius < obs.holeY + obs.holeHeight/2) {
        // Pas de collision => possible de marquer point si obstacle pass√©
        if(obs.x + obstacleWidth < ballX) {
          if(!obs.passed) {
            score++;
            obs.passed = true;
            // Nouveau obstacle bient√¥t
            setTimeout(createObstacle, 1200);
          }
        }
      } else {
        // Collision = fin jeu
        gameOver = true;
      }
    }
  }
  // Si balle sort du canvas haut ou bas -> fin jeu
  if(ballY - ballRadius < 0 || ballY + ballRadius > CANVAS_HEIGHT) {
    gameOver = true;
  }
}

// Lecture micro pendant le jeu pour hauteur actuelle
let gameStream, gameAudioCtx, gameSource, gameAnalyser;
let gameBuffer;

function startGameMicListening() {
  return new Promise(async (resolve, reject) => {
    try {
      gameStream = await getUserMediaStream();
      gameAudioCtx = new AudioContext();
      gameSource = gameAudioCtx.createMediaStreamSource(gameStream);
      gameAnalyser = gameAudioCtx.createAnalyser();
      gameAnalyser.fftSize = 2048;
      gameSource.connect(gameAnalyser);
      gameBuffer = new Float32Array(gameAnalyser.fftSize);
      resolve();
    } catch(e) {
      alert("Erreur : impossible d'acc√©der au micro pour le jeu.");
      reject(e);
    }
  });
}

function stopGameMicListening() {
  if(gameAnalyser) gameAnalyser.disconnect();
  if(gameSource) gameSource.disconnect();
  if(gameAudioCtx) gameAudioCtx.close();
  if(gameStream) gameStream.getTracks().forEach(t => t.stop());
  gameAnalyser = null;
  gameSource = null;
  gameAudioCtx = null;
  gameStream = null;
}

// Boucle jeu
function gameLoop() {
  frameCount++;
  drawGameBackground();

  // R√©cup fr√©quence micro en temps r√©el
  let currentFreq = null;
  if(gameAnalyser) {
    gameAnalyser.getFloatTimeDomainData(gameBuffer);
    let pitch = autoCorrelate(gameBuffer, gameAudioCtx.sampleRate);
    if(pitch >= lowFreq && pitch <= highFreq) currentFreq = pitch;
  }

  updateBallPosition(currentFreq);
  drawObstacles();
  drawBall();
  checkCollision();

  scoreDisplay.textContent = `Score : ${score}`;
  if(gameOver) {
    cancelAnimationFrame(animationId);
    scoreDisplay.textContent += "  -  FIN DU JEU";
    replayBtn.style.display = 'block';
    stopGameMicListening();
    return;
  }
  animationId = requestAnimationFrame(gameLoop);
}

async function startGame() {
  stopListening();
  menuDiv.style.display = 'none';
  canvas.style.display = 'block';
  replayBtn.style.display = 'none';

  lowFreq = detectedLowFreq;
  highFreq = detectedHighFreq;

  // reset variables
  ballX = CANVAS_WIDTH / 4;
  ballY = CANVAS_HEIGHT / 2;
  ballSpeedX = 3;
  ballSpeedY = 0;
  obstacles = [];
  frameCount = 0;
  score = 0;
  gameOver = false;

  createObstacle();

  await startGameMicListening();

  gameLoop();
}

startGameBtn.addEventListener('click', () => {
  startGame();
});

replayBtn.addEventListener('click', () => {
  startGame();
});

</script>
</body>
</html>
