<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jeu vocal ‚Äî Balle chant√©e</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: sans-serif;
      background: linear-gradient(135deg, #ffeb3b, #ff9800, #000);
      overflow: hidden;
    }
    #backgroundSymbols {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    #menu {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.75);
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      z-index: 2;
      color: white;
      width: 90%;
      max-width: 360px;
    }
    button {
      display: block;
      width: 100%;
      padding: 12px;
      margin: 10px auto;
      font-size: 1.1em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
    }
    button:disabled {
      background: #888;
      color: #333;
      cursor: not-allowed;
    }
    .note-btn { background: #e91e63; color: white; }
    .note-btn.listening { background: #4caf50; }
    .note-display { margin: 8px 0; font-size: 1.3em; min-height: 1.4em; }
    .freq-display { font-size: 1em; color: #ffc; }
    #startGameBtn { background: #ff9800; color: black; }

    #gameCanvas {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: transparent;
      border: 3px solid #ff9800;
      border-radius: 15px;
      z-index: 1;
      display: none;
    }
    #scoreDisplay {
      position: fixed;
      top: 20px; right: 20px;
      font-size: 24px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 1px 1px 3px #000;
      z-index: 2;
    }
    #replayBtn {
      position: fixed;
      bottom: 20px; right: 20px;
      padding: 12px 20px;
      background: #ff9800;
      color: black;
      border: none;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      display: none;
      z-index: 2;
    }
  </style>
</head>
<body>

<canvas id="backgroundSymbols"></canvas>

<div id="menu">
  <h1>Choisis ta tessiture</h1>
  <button id="listenLowBtn" class="note-btn">üé§ √âcouter note basse</button>
  <div class="note-display" id="lowNoteDisplay">‚Äì</div>
  <div class="freq-display" id="lowFreqDisplay"></div>

  <button id="listenHighBtn" class="note-btn">üé§ √âcouter note haute</button>
  <div class="note-display" id="highNoteDisplay">‚Äì</div>
  <div class="freq-display" id="highFreqDisplay"></div>

  <button id="startGameBtn" disabled>D√©marrer le jeu</button>
</div>

<canvas id="gameCanvas" width="480" height="640"></canvas>
<div id="scoreDisplay"></div>
<button id="replayBtn">Rejouer</button>

<script src="https://unpkg.com/pitchfinder/dist/pitchfinder.umd.js"></script>
<script>
  const detectPitch = Pitchfinder.YIN();

<script>
  // === Fond anim√© ===
  const bg = document.getElementById('backgroundSymbols');
  const bgCtx = bg.getContext('2d');
  const syms = ['‚ô©','‚ô™','‚ô´','‚ô¨','‚ô≠','‚ôØ'];
  let objs = [];

  function resizeBg() {
    bg.width = window.innerWidth;
    bg.height = window.innerHeight;
    objs = Array.from({length: 80}, () => ({
      x: Math.random()*bg.width,
      y: Math.random()*bg.height,
      size: 12 + Math.random()*30,
      angle: (Math.random()-0.5)*1,
      sym: syms[Math.floor(Math.random()*syms.length)],
      alpha: 0.02 + Math.random()*0.06
    }));
  }

  function animateBg() {
    bgCtx.clearRect(0, 0, bg.width, bg.height);
    objs.forEach(o => {
      bgCtx.save();
      bgCtx.translate(o.x, o.y);
      bgCtx.rotate(o.angle);
      bgCtx.globalAlpha = o.alpha;
      bgCtx.fillStyle = "#fff";
      bgCtx.font = `${o.size}px serif`;
      bgCtx.fillText(o.sym, 0, 0);
      bgCtx.restore();
    });
    requestAnimationFrame(animateBg);
  }

  window.addEventListener('resize', resizeBg);
  resizeBg();
  animateBg();

  // === D√©tection micro et tessiture ===
  let audioCtx, analyser, buf, stream, listeningFor = null;
  let lowFreq = null, highFreq = null;

  const lowNote = document.getElementById("lowNoteDisplay");
  const highNote = document.getElementById("highNoteDisplay");
  const lowFreqDisplay = document.getElementById("lowFreqDisplay");
  const highFreqDisplay = document.getElementById("highFreqDisplay");

  const listenLowBtn = document.getElementById("listenLowBtn");
  const listenHighBtn = document.getElementById("listenHighBtn");
  const startGameBtn = document.getElementById("startGameBtn");

listenLowBtn.onclick = () => {
  if (listeningFor === 'low') {
    stopListen();
  } else {
    startListen('low');
  }
};

listenHighBtn.onclick = () => {
  if (listeningFor === 'high') {
    stopListen();
  } else {
    startListen('high');
  }
};

async function safeCloseAudioContext() {
  if (!audioCtx) return;
  try {
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    if (audioCtx.state !== 'closed') await audioCtx.close();
  } catch (e) {
    console.warn("Erreur lors de la fermeture de AudioContext :", e);
  } finally {
    audioCtx = null;
  }
}

let isStopping = false;

async function stopListen() {
  if (isStopping) return;
  isStopping = true;

  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }

  await safeCloseAudioContext();

  listeningFor = null;
  [listenLowBtn, listenHighBtn].forEach(b => b.classList.remove('listening'));
  listenLowBtn.textContent = "üé§ √âcouter note basse";
  listenHighBtn.textContent = "üé§ √âcouter note haute";
  lowNote.textContent = highNote.textContent = "‚Äì";
  lowFreqDisplay.textContent = highFreqDisplay.textContent = "";
  lowFreq = highFreq = null;
  startGameBtn.disabled = true;

  isStopping = false;
}

async function startListen(type) {
  stopListen();
  listeningFor = type;
  const btn = (type === 'low') ? listenLowBtn : listenHighBtn;
  btn.classList.add('listening');
  btn.textContent = (type === 'low') ? "‚è∏ Arr√™ter √©coute basse" : "‚è∏ Arr√™ter √©coute haute";

  try {
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    await audioCtx.resume();

    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    buf = new Float32Array(analyser.fftSize);
    src.connect(analyser);

    detectPitchLoop();
  } catch (e) {
    alert("Micro inaccessible.");
    listeningFor = null;
    btn.classList.remove('listening');
    btn.textContent = (type === 'low') ? "üé§ √âcouter note basse" : "üé§ √âcouter note haute";
  }
}

  function autoCorrelate(buffer, sr) {
  let SIZE = buffer.length,
      MAX = Math.floor(SIZE / 2),
      best = -1,
      bestC = 0,
      rms = 0;

  for (let i = 0; i < SIZE; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / SIZE);
  if (rms < 0.01) return -1;

  for (let off = 0; off < MAX; off++) {
    let corr = 0;
    for (let i = 0; i < MAX; i++)
      corr += Math.abs(buffer[i] - buffer[i + off]);
    corr = 1 - corr / MAX;
    if (corr > bestC) {
      bestC = corr;
      best = off;
    }
  }

  if (best <= 0) return -1; // √âvite division par z√©ro

  return bestC > 0.9 ? sr / best : -1;
}

  function freqToNoteLabel(freq) {
    const noteNames = ["Do", "Do‚ôØ", "R√©", "R√©‚ôØ", "Mi", "Fa", "Fa‚ôØ", "Sol", "Sol‚ôØ", "La", "La‚ôØ", "Si"];
    const flatEquivs = { "Do‚ôØ":"R√©‚ô≠", "R√©‚ôØ":"Mi‚ô≠", "Fa‚ôØ":"Sol‚ô≠", "Sol‚ôØ":"La‚ô≠", "La‚ôØ":"Si‚ô≠" };
    const noteNumber = 12 * (Math.log2(freq / 440)) + 69;
    const rounded = Math.round(noteNumber);
    const noteIndex = (rounded + 1200) % 12; // Pour rester dans les 0-11
    let name = noteNames[noteIndex];
    const octave = Math.floor(rounded / 12) - 1;

    // Remplacer par b√©mols si souhait√©
    if (flatEquivs[name]) name = flatEquivs[name];

    return name + octave;
  }

function detectPitchLoop() {
  if (!listeningFor || !audioCtx || !analyser) return;
  analyser.getFloatTimeDomainData(buf);
  const freq = detectPitch(buf); // ton d√©tecteur YIN
  console.log("freq d√©tect√©e :", freq);

  if (freq && isFinite(freq)) {
    const noteLabel = freqToNoteLabel(freq);
    const freqLabel = `${freq.toFixed(1)} Hz`;
    if (listeningFor === 'low') {
      lowNote.textContent = noteLabel;
      lowFreqDisplay.textContent = freqLabel;
      lowFreq = freq;
    } else {
      highNote.textContent = noteLabel;
      highFreqDisplay.textContent = freqLabel;
      highFreq = freq;
    }
    if (lowFreq && highFreq && highFreq > lowFreq + 10) {
      startGameBtn.disabled = false;
    }
  } else {
    if (listeningFor === 'low') {
      lowNote.textContent = "‚Äì";
      lowFreqDisplay.textContent = "";
      lowFreq = null;
    } else {
      highNote.textContent = "‚Äì";
      highFreqDisplay.textContent = "";
      highFreq = null;
    }
    startGameBtn.disabled = true;
  }

  requestAnimationFrame(detectPitchLoop);
}

  // === Jeu ===
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const replayBtn = document.getElementById('replayBtn');
  const menuDiv = document.getElementById('menu');

  let gameRunning = false;
  let obstacles = [];
  let ball = { x: 50, y: 0, radius: 15, vy: 0 };
  let gravity = 0.6;
  let jumpStrength = -10;
  let frameCount = 0;
  let score = 0;

  // D√©finir hauteur minimale et maximale en pixel pour le jeu
  const gameHeight = canvas.height;
  const gameWidth = canvas.width;

  function freqToY(freq) {
    // Transforme fr√©quence en position Y dans canvas
    // Plus freq haute = balle en haut, plus freq basse = balle en bas
    if (!lowFreq || !highFreq) return gameHeight/2;
    let clampedFreq = Math.min(Math.max(freq, lowFreq), highFreq);
    let ratio = (clampedFreq - lowFreq) / (highFreq - lowFreq);
    return gameHeight - ratio * gameHeight;
  }

  function createObstacle() {
    const holeHeight = 120;
    const holeY = Math.random() * (gameHeight - holeHeight);
    return {
      x: gameWidth + 20,
      width: 50,
      holeY: holeY,
      holeHeight: holeHeight,
      passed: false
    };
  }

  function resetGame() {
    obstacles = [];
    ball.x = 50;
    ball.y = gameHeight / 2;
    ball.vy = 0;
    frameCount = 0;
    score = 0;
    scoreDisplay.textContent = "Score: 0";
    replayBtn.style.display = 'none';
  }

  function gameOver() {
    gameRunning = false;
    replayBtn.style.display = 'block';
  }

  function drawObstacle(obs) {
    ctx.fillStyle = '#ff9800';
    // Dessiner rectangle haut
    ctx.fillRect(obs.x, 0, obs.width, obs.holeY);
    // Dessiner rectangle bas
    ctx.fillRect(obs.x, obs.holeY + obs.holeHeight, obs.width, gameHeight - (obs.holeY + obs.holeHeight));
  }

  function drawBall() {
    ctx.beginPath();
    ctx.fillStyle = '#e91e63';
    ctx.shadowColor = 'rgba(255, 20, 147, 0.7)';
    ctx.shadowBlur = 12;
    ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  function update() {
    if (!gameRunning) return;

    frameCount++;
    // G√©n√©rer obstacles tous les 120 frames (~2s)
    if (frameCount % 120 === 0) {
      obstacles.push(createObstacle());
    }

    // D√©placer obstacles
    obstacles.forEach(obs => {
      obs.x -= 3;
    });

    // Supprimer obstacles pass√©s hors √©cran
    obstacles = obstacles.filter(obs => obs.x + obs.width > 0);

    // Mettre √† jour la position de la balle selon la voix d√©tect√©e
    let freq = -1;
    if (audioCtx && analyser && buf) {
      analyser.getFloatTimeDomainData(buf);
      freq = autoCorrelate(buf, audioCtx.sampleRate);
    }

    if (freq > 0) {
      ball.y = freqToY(freq);
    }

    // V√©rifier collisions
    for (const obs of obstacles) {
      if (ball.x + ball.radius > obs.x && ball.x - ball.radius < obs.x + obs.width) {
        if (ball.y - ball.radius < obs.holeY || ball.y + ball.radius > obs.holeY + obs.holeHeight) {
          gameOver();
          break;
        }
      }
      if (!obs.passed && obs.x + obs.width < ball.x) {
        obs.passed = true;
        score++;
        scoreDisplay.textContent = "Score: " + score;
      }
    }

    draw();
    requestAnimationFrame(update);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Fond notes comme en arri√®re-plan
    drawBackgroundSymbolsInGame();

    obstacles.forEach(drawObstacle);
    drawBall();
  }

  // Fond du jeu (plus simple version des symboles)
  function drawBackgroundSymbolsInGame() {
    const symbols = ['‚ô©','‚ô™','‚ô´','‚ô¨','‚ô≠','‚ôØ'];
    ctx.fillStyle = 'rgba(255, 235, 59, 0.1)';
    ctx.font = '30px serif';
    for (let i = 0; i < 15; i++) {
      const sym = symbols[i % symbols.length];
      const x = (i * 60 + frameCount * 2) % canvas.width;
      const y = (i * 40 + frameCount) % canvas.height;
      ctx.fillText(sym, x, y);
    }
  }

  startGameBtn.onclick = () => {
    if (!lowFreq || !highFreq || highFreq <= lowFreq + 10) {
      alert("Veuillez d√©finir correctement la tessiture (note basse et note haute).");
      return;
    }
    menuDiv.style.display = 'none';
    canvas.style.display = 'block';
    scoreDisplay.style.display = 'block';
    replayBtn.style.display = 'none';
    gameRunning = true;
    resetGame();

    // D√©marrer l'√©coute micro pour le jeu
    startGameMic();
    update();
  };

  replayBtn.onclick = () => {
    replayBtn.style.display = 'none';
    resetGame();
    gameRunning = true;
    update();
  };

  function startGameMic() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    if (audioCtx) audioCtx.close();

    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(s => {
        stream = s;
        audioCtx = new AudioContext();
        const src = audioCtx.createMediaStreamSource(stream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        buf = new Float32Array(analyser.fftSize);
        src.connect(analyser);
      })
      .catch(() => alert("Microphone non accessible, jeu indisponible."));
  }

  // Remise au menu apr√®s game over
  replayBtn.addEventListener('click', () => {
    if (!gameRunning) {
      menuDiv.style.display = 'block';
      canvas.style.display = 'none';
      scoreDisplay.style.display = 'none';
      stopListen();
    }
  });

  // Arr√™ter l'√©coute si on revient au menu (replay avant lancement)
  function stopListen() {
    if (stream) stream.getTracks().forEach(t => t.stop());
    if (audioCtx) audioCtx.close();
    listeningFor = null;
    [listenLowBtn, listenHighBtn].forEach(b => b.classList.remove('listening'));
    listenLowBtn.textContent = "üé§ √âcouter note basse";
    listenHighBtn.textContent = "üé§ √âcouter note haute";
  }
</script>
</body>
</html>
